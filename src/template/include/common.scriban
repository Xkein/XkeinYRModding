{{
    # helpers for meta BEGIN
    func has_meta(meta)
        ret meta && meta.raw.has_meta
    end

    func get_meta_tag(meta, key)
        ret meta.raw.meta_data.tags[key]
    end

    func get_meta_key_value(meta, key)
        ret meta.raw.meta_data.kvPairs[key]
    end
    # helpers for meta END

    func init_extra_vars(htType)
        if htType.cpp_class
            htType.is_class = true
            htType.class_name = htType.cpp_class.name
            htType.gen_type_name = get_gen_type_name(htType.class_name)
            htType.class_is_abstract = htType.cpp_class.is_abstract
            htType.class_functions = htType.functions
            htType.class_properties = htType.properties
        else if htType.cpp_enum
            htType.is_enum = true
            htType.enum_name = htType.cpp_enum.name
            htType.gen_type_name = get_gen_type_name(htType.enum_name)
            htType.enum_constants = htType.constants
        else if htType.module_name
            htType.is_module = true
            htType.gen_type_name = get_gen_type_name(htType.module_name)
            htType.module_classes = htType.classes
            htType.module_enums = htType.enums
        end
        
        $meta = htType.meta
        if has_meta($meta)
            htType.all_visible = get_meta_tag(meta, "AllVisible")
            htType.all_public_visible = get_meta_tag(meta, "AllPublicVisible")
        end
    end

    func should_skip_visibility(htType, htElement)
        $has_meta = has_meta(htElement.meta)
        case htElement.element.visibility
            when 2, 3 # protected or private
                ret !(htType.all_visible || $has_meta)
            else
                ret !(htType.all_visible || htType.all_public_visible || $has_meta)
        end
    end

    func get_gen_type_name(name)
        ret "__Gen_Type_"+name
    end

    func get_calling_convention(callConvention)
        case callConvention
            when 2 # X86StdCall
                ret "__stdcall"
            when 3 # X86FastCall
                ret "__fastcall"
            else
                ret ""
        end
    end

    func get_function_ptr_type(htFunction, htClass)
        $cpp_function = htFunction.cpp_function
        $func_type = $"{$cpp_function.return_type.full_name}"
        $func_type += "("
        $func_type += get_calling_convention($cpp_function.calling_convention)
        if $cpp_function.is_cxx_class_method && !$cpp_function.is_static
            $func_type += $" {htClass.cpp_class.name}::*"
        else
            $func_type += "*"
        end
        $func_type += ")"

        $arg_types = (htFunction.cpp_function.parameters | array.each do; ret $0.type.full_name; end) | array.join ", "
        $func_type += $"({$arg_types})"
        if $cpp_function.is_const
            $func_type += " const"
        end
        ret $func_type
    end

    func get_function_lambda_wrap(htFunction, htClass)
        $cpp_function = htFunction.cpp_function
        $return_type = $cpp_function.return_type.full_name
        $lambda = $"[]("
        if $cpp_function.is_cxx_class_method && !$cpp_function.is_static
            if $cpp_function.is_const
               $lambda += "const " 
            end
            $lambda += $"{htClass.cpp_class.name}* _this"
            if array.size(htFunction.cpp_function.parameters) > 0
                $lambda += ", "
            end
        end
        $lambda += (htFunction.cpp_function.parameters | array.each do; ret $0; end) | array.join ", "
        $lambda += ")"
        $lambda += $" -> {$return_type} "
        $lambda += "{ "
        if $return_type != "void"
            $lambda += "return "
        end
        
        $function_name = htFunction.cpp_function.name
        if $cpp_function.is_cxx_class_method
            $class_name = htClass.cpp_class.name
            if $cpp_function.is_static
                $lambda += $"{$class_name}::{$function_name}"
            else
                $lambda += $"_this->{$function_name}"
            end
        end
        $lambda += "("
        $lambda += (htFunction.cpp_function.parameters | array.each do; ret $0.name; end) | array.join ", "
        $lambda += "); }"
        ret $lambda
    end

    # helpers to generate rttr BEGIN

    func gen_rttr_function_register(htFunction, htClass)
        $cpp_function = htFunction.cpp_function

        case $cpp_function.calling_convention
            when 2 # X86StdCall
                ret "__stdcall"
            when 3 # X86FastCall
                ret "__fastcall"
            else
                ret ""
        end
    end

    func rttr_should_use_lambda(htFunction)
        case htFunction.cpp_function.calling_convention
            when 2, 3 # X86StdCall, X86FastCall
                ret true
            else
                ret false
        end
    end

    func gen_rttr_class_function(htClass, htFunction)
        if should_skip_visibility(htClass, htFunction) || htFunction.cpp_function.is_destructor || htFunction.cpp_function.is_static # static not considered
            ret null
        end
        $use_lambda = rttr_should_use_lambda(htFunction)
        $lambda = $use_lambda ? get_function_lambda_wrap(htFunction, htClass) : null
        if htFunction.cpp_function.is_constructor
            if htClass.class_is_abstract
                ret null
            end
            $arg_types = (htFunction.cpp_function.parameters | array.each do; ret $0.type.full_name; end) | array.join ", "
            if $use_lambda
                ret $".constructor<{$arg_types}>({$lambda})"
            else
                ret $".constructor<{$arg_types}>()"
            end
        end
        $class_name = htClass.cpp_class.name
        $function_name = htFunction.cpp_function.name
        $func_type = get_function_ptr_type(htFunction, htClass)
        
        if $use_lambda
            ret $".method(\"{$function_name}\", {$lambda})"
        else if htFunction.is_overload
            ret $".method(\"{$function_name}\", static_cast<{$func_type}>(&{$class_name}::{$function_name}))"
        else
            ret $".method(\"{$function_name}\", &{$class_name}::{$function_name})"
        end
    end

    func gen_rttr_class_property(htClass, htProperty)
        if should_skip_visibility(htClass, htProperty) || htProperty.cpp_field.storage_qualifier == 2 # static not considered
            ret null
        end
        $class_name = htClass.cpp_class.name
        $field_name = property.cpp_field.name
        ret $".property(\"{$field_name}\", &{class_name}::{$field_name})"
    end

    func gen_rttr_enum_constant(htEnum, htConstant)
        $enum_name = htEnum.cpp_enum.name
        $enum_const_name = htConstant.cpp_enum_item.name
        ret $"value(\"{$enum_const_name}\", {$enum_name}::{$enum_const_name})"
    end

    # helpers to generate rttr END

}}