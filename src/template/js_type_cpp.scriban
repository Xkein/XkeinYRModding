{{- include 'include/meta.scriban'
    is_yrpp = module.module_name == "YRpp"
    if is_yrpp
        include 'yr/yrpp.scriban'
        func need_codegen(htType)
            ret has_meta(htType.meta) || (is_yrpp && yr_need_codegen(htType))
        end
        if !yr_need_codegen(this)
            ret
        end
    else
        if !has_meta(meta) || get_meta_tag(meta, "HookEvent")
            ret
        end
    end
    init_extra_vars(this)
    if is_yrpp
        yr_inject_meta(this)
    end
-}}
{{- if is_yrpp -}}
#include "scripting/javascript/yr_data_bindings.h"
#include <EventClass.h>
#include <YRPP.h>
#include <CRC.h>
#include <HouseClass.h>
#include <ColorScheme.h>
#include <TriggerTypeClass.h>
{{- end }}
#include "{{source_file}}"
#include "core/raii_invoker.h"
#include <Binding.hpp>
void __JsRegister_{{type_name}}() {
{{ if is_class }}
    auto builder = PUERTS_NAMESPACE::DefineClass<{{type_name}}>();
    {{- for base in base_classes }}
        {{- if base.klass && !base.klass.is_interface}}
    builder.Extends<{{base.full_display_name}}>();
        {{- end }}
    {{- end }}
    {{- for function in class_functions ; $cpp_function = function.cpp_function }}
        {{- if should_skip_visibility(this, function) || function.is_deleted || function.is_destructor || function.is_constructor
            continue
        end
        $use_lambda = meta_should_use_lambda(function)
        if $use_lambda ; $lambda = $use_lambda ? get_function_lambda_wrap(function, this) : null }}
        //.Function("{{function.name}}", MakeFunction({{$lambda}}))
        {{- else if function.is_static }}
            {{- if function.is_overload ; $func_type = get_function_ptr_type(function, this)}}
    builder.Function("{{function.name}}", MakeFunction(static_cast<{{$func_type}}>(&{{type_name}}::{{function.name}})));
            {{- else }}
    builder.Function("{{function.name}}", MakeFunction(&{{type_name}}::{{function.name}}));
            {{- end }}
        {{- else if function.is_overload ; $func_type = get_function_ptr_type(function, this)}}
    builder.Method("{{function.name}}", MakeFunction(static_cast<{{$func_type}}>(&{{type_name}}::{{function.name}})));
        {{- else }}
    builder.Method("{{function.name}}", MakeFunction(&{{type_name}}::{{function.name}}));
        {{- end -}}
    {{- end }}
    {{- for property in class_properties ; $cpp_field = property.cpp_field }}
        {{- if string.empty(property.name) || should_skip_visibility(this, property)
            continue
        end }}
        {{- if property.is_static && (property.is_const || property.is_constexpr || property.is_array) }}
    builder.Variable("{{property.name}}", MakeReadonlyVariable(std::addressof({{type_name}}::{{property.name}})));
        {{- else if property.is_const || property.is_array }}
    builder.Property("{{property.name}}", MakeReadonlyProperty(&{{type_name}}::{{property.name}}));
        {{- else if property.is_static }}
    builder.Variable("{{property.name}}", MakeVariable(std::addressof({{type_name}}::{{property.name}})));
        {{- else }}
    MakePropertyCheck<&{{type_name}}::{{property.name}}>(builder, "{{property.name}}");
        {{- end -}}
    {{- end }}
    builder.Register();
{{ else if is_enum }}

{{ end }}
}
GLOBAL_INVOKE_ON_CTOR(__JsRegister_{{type_name}});
